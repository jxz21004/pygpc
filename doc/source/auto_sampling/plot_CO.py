"""
Coherence optimal sampling
==========================

ADD THEORY OF CO GRIDS HERE

Example
-------
In order to create a grid of sampling points, we have to define the random parameters and create a gpc object.
"""

import pygpc
import numpy as np
import matplotlib.pyplot as plt
from collections import OrderedDict

# define model
model = pygpc.testfunctions.RosenbrockFunction()

# define random parameters
parameters = OrderedDict()
parameters["x1"] = pygpc.Beta(pdf_shape=[1, 1], pdf_limits=[-np.pi, np.pi])
parameters["x2"] = pygpc.Beta(pdf_shape=[1, 1], pdf_limits=[-np.pi, np.pi])

# define problem
problem = pygpc.Problem(model, parameters)

# create gpc object
gpc = pygpc.Reg(problem=problem,
                order=[5]*problem.dim,
                order_max=5,
                order_max_norm=1,
                interaction_order=2,
                interaction_order_current=2,
                options=None,
                validation=None)

###############################################################################
# A coherence optimal grid containing 200 sampling points can be generated by:

grid = pygpc.CO(parameters_random=parameters,
                n_grid=200,
                gpc=gpc,
                options={"seed": None,
                         "n_warmup": 1000})

###############################################################################
# The following options are available for coherence optimal grids:
#
# - seed: set a seed to reproduce the results (default: None)
# - warmup: number of warmup samples (default: 1000)
#
# The grid points are distributed as follows (in the normalized space):

fig = plt.figure(figsize=(4, 3.5))
plt.scatter(grid.coords_norm[:, 0], grid.coords_norm[:, 1], c="r")
plt.xlabel("$x_1$", fontsize=12)
plt.ylabel("$x_2$", fontsize=12)
plt.xlim([-1, 1])
plt.ylim([-1, 1])
plt.xticks(np.linspace(-1, 1, 5))
plt.yticks(np.linspace(-1, 1, 5))
plt.grid()
plt.tight_layout()

###############################################################################
# The sampling method can be selected accordingly for each gPC algorithm by setting the following options
# when setting up the algorithm:
options = dict()
...
options["grid"] = pygpc.CO
options["grid_options"] = {"seed": None,
                           "n_warmup": 1000}
...

# When using Windows you need to encapsulate the code in a main function and insert an
# if __name__ == '__main__': guard in the main module to avoid creating subprocesses recursively:
#
# if __name__ == '__main__':
#     main()
